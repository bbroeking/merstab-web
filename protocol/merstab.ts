// @ts-ignore
import { getMint, getAssociatedTokenAddress, createAssociatedTokenAccountInstruction, createMint, TOKEN_PROGRAM_ID, getAccount } from '@solana/spl-token';
import * as anchor from '@project-serum/anchor';
import { Keypair, PublicKey, sendAndConfirmTransaction, Signer, SystemProgram, SYSVAR_RENT_PUBKEY, Transaction } from '@solana/web3.js';
import idl from "./idls/merstab_protocol.json";

export interface VaultMetadata {
    manager: PublicKey,
    mint: PublicKey,
    name: string,
}

/**
 * Wallet interface for objects that can be used to sign provider transactions.
 */
export interface Wallet {
    signTransaction: (transaction: Transaction) => Promise<Transaction>;
    signAllTransactions: (transaction: Transaction[]) => Promise<Transaction[]>;
    publicKey: PublicKey;
}
export class MerstabClient {
    connection: anchor.web3.Connection;
    constructor(public program: anchor.Program, public network: string) { 
        this.connection = program.provider.connection;
    }

    static async connect(provider: anchor.AnchorProvider, network: string): Promise<MerstabClient> {
        const program = new anchor.Program(idl as any, MerstabClient.MERSTAB_ID, provider);
        return new MerstabClient(program, network);
    }
    static MERSTAB_ID = new PublicKey("AQPDVpAsDtd8cfXVjrUEKrhchF4cYwST2wyq3tJa82ci");
    static MANGO_OWNER_PDA_SEED = 'mango_owner_pda_seed';
    static STAKED_TOKENS_PDA_SEED = 'staked_token_mint_authority';
    static VAULT_SEED = 'vault-seed';

    async getTokenAccount(quoteMint: PublicKey, wallet: PublicKey) {
        const mUSDCStakerAccount = await getAssociatedTokenAddress(quoteMint, wallet);
        return await getAccount(mUSDCStakerAccount);
    }

    async getMTokenAccount(vault: PublicKey, wallet: PublicKey) {
        const vaultData: VaultMetadata = await this.getVaultData(vault);
        const merstabUSDCMint = vaultData.mint;
        const mUSDCStakerAccount = await getAssociatedTokenAddress(merstabUSDCMint, wallet);
        return await getAccount(mUSDCStakerAccount);
    }

    async getVaultValue(vaultName: string) {
        const [account, bump] = await this.deriveVaultAccount(vaultName);
        return await getAccount(account);
    }

    async getVaultData(key: PublicKey): Promise<VaultMetadata> {
        return (await this.program.account.vault.fetch(key)) as unknown as VaultMetadata;
    }

    async deriveMangoAccount(vaultName: string) {
        return await PublicKey.findProgramAddress(
            [
                Buffer.from(anchor.utils.bytes.utf8.encode(MerstabClient.MANGO_OWNER_PDA_SEED)),
                Buffer.from(anchor.utils.bytes.utf8.encode(vaultName)),
            ],
            this.program.programId
        );
    }

    async deriveVaultAccount(vaultName: string) {
        return await PublicKey.findProgramAddress(
            [
                Buffer.from(anchor.utils.bytes.utf8.encode(MerstabClient.VAULT_SEED)),
                Buffer.from(anchor.utils.bytes.utf8.encode(vaultName))
            ],
            this.program.programId
        );
    }

    async deriveMTokenAuthority(vaultName: string) {
        return await PublicKey.findProgramAddress(
            [
                Buffer.from(anchor.utils.bytes.utf8.encode(MerstabClient.STAKED_TOKENS_PDA_SEED)),
                Buffer.from(anchor.utils.bytes.utf8.encode(vaultName)),
            ],
            this.program.programId
        );
    }

    // node helper function
    async addVault(vaultName: string, wallet: Keypair) {
        const vault = Keypair.generate();
        console.log(`New vault public key ${vault.publicKey.toString()}`);

        const [mangoOwnerPDA, mangoOwnerBump] = await this.deriveMangoAccount(vaultName);
        const [tokenAccountPDA, tokenAccountBump] = await this.deriveVaultAccount(vaultName);

        const stakedMint = await createMint(
            this.connection,
            wallet,
            wallet.publicKey,
            wallet.publicKey,
            6,
            anchor.web3.Keypair.generate(),
            null,
            TOKEN_PROGRAM_ID
        );
        console.log(`Staked token mint: ${stakedMint.toString()}`);

        // generated by me
        const quoteMint = new PublicKey("BNH9xMad6Gh3qxGPbkwKE221gepfuUPMGs9XLGpVeBmv");

        this.program.methods
            .addVault(vaultName, mangoOwnerBump)
            .accounts({
                vault: vault.publicKey,
                manager: wallet.publicKey,
                tokenAccount: tokenAccountPDA,
                tokenAccountAuthority: mangoOwnerPDA,
                stakedTokenMint: stakedMint,
                payer: wallet.publicKey,
                mint: quoteMint,
                rent: SYSVAR_RENT_PUBKEY,
                tokenProgram: TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
            })
            .signers([vault, wallet])
            .rpc()
    }

    async stake(amount: anchor.BN, wallet: PublicKey, vaultPk?: PublicKey, keypair?: Keypair) {
        // get these values from add vault
        const vault = vaultPk ? vaultPk : new PublicKey("5Fczud8oRx8f9yQhMcvW9EpehEpRyai5MBJieEgbTjfD");
        const vaultData: VaultMetadata = await this.getVaultData(vault);
        const vaultName = vaultData.name;
        const merstabUSDCMint = vaultData.mint;

        // init tx
        const tx = new Transaction();

        const mUSDCStakerAccount = await getAssociatedTokenAddress(merstabUSDCMint, wallet);
        const merstabTokenAccountInfo = await getAccount(this.connection, mUSDCStakerAccount);
        if (!merstabTokenAccountInfo) {
            const ataIx = createAssociatedTokenAccountInstruction(
                wallet,
                mUSDCStakerAccount,
                wallet,
                merstabUSDCMint,
            )
            tx.add(ataIx);    
        }

        // should be 22VpUEiJp7nXw3us2Eczz1R2xhdFaACT5xTcDWLEiZxv
        const walletUSDCAccount = await getAssociatedTokenAddress(new PublicKey("BNH9xMad6Gh3qxGPbkwKE221gepfuUPMGs9XLGpVeBmv"), wallet);
        const [tokenAccountPDA, tokenAccountBump] = await this.deriveVaultAccount(vaultName);
        const [stakedTokenMintPDA, stakedTokenMintBump] = await this.deriveMTokenAuthority(vaultName);

        try {
            const ix = await this.program.methods
                .stake(amount, tokenAccountBump, stakedTokenMintBump)
                .accounts({
                    vault: vault,
                    vaultTokenAccount: tokenAccountPDA, // vault USDC
                    stakersTokenAccount: walletUSDCAccount, // user USDC
                    stakersAta: mUSDCStakerAccount, // user merUSDC
                    stakedTokenMintAuthority: stakedTokenMintPDA, // should be same as mUSDCMint.mintAuthority
                    staker: wallet,
                    stakedTokenMint: merstabUSDCMint,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                .instruction();
            tx.add(ix);

            const txId = await sendAndConfirmTransaction(this.connection, tx, [keypair as anchor.web3.Signer]);
            console.log(`txhash: ${txId}`);
            return txId;
        } catch (err) {
            console.log(err);
            return err;
        }
    }

    async unstake(amount: anchor.BN, wallet: PublicKey, vaultPk?: PublicKey, keypair?: Keypair) {
        // get these values from add vault
        const vault = vaultPk ? vaultPk : new PublicKey("5Fczud8oRx8f9yQhMcvW9EpehEpRyai5MBJieEgbTjfD");
        const vaultData: VaultMetadata = await this.getVaultData(vault);
        const vaultName = vaultData.name;
        const merstabUSDCMint = vaultData.mint;

        const mUSDCMint = await getMint(this.connection, merstabUSDCMint, null, TOKEN_PROGRAM_ID);
        const mUSDCStakerAccount = await getAssociatedTokenAddress(merstabUSDCMint, wallet);

        // should be 22VpUEiJp7nXw3us2Eczz1R2xhdFaACT5xTcDWLEiZxv
        const walletUSDCAccount = await getAssociatedTokenAddress(new PublicKey("BNH9xMad6Gh3qxGPbkwKE221gepfuUPMGs9XLGpVeBmv"), wallet);
        const [mangoOwnerPDA, mangoOwnerBump] = await this.deriveMangoAccount(vaultName);
        const [tokenAccountPDA, tokenAccountBump] = await this.deriveVaultAccount(vaultName);
        const [stakedTokenMintPDA, stakedTokenMintBump] = await this.deriveMTokenAuthority(vaultName);

        try {
            const ix = await this.program.methods
                .unstake(new anchor.BN(amount), mangoOwnerBump)
                .accounts({
                    vault: vault,
                    vaultTokenAccount: tokenAccountPDA,
                    vaultTokenAuthority: mangoOwnerPDA,
                    stakersTokenAccount: walletUSDCAccount,
                    stakersAta: mUSDCStakerAccount,
                    stakedTokenMintAuthority: stakedTokenMintPDA,
                    staker: wallet,
                    stakedTokenMint: merstabUSDCMint,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                .instruction()
            const tx = new Transaction().add(ix);
            // should send via useWallet hook
            const signers = keypair ? [keypair as Signer] : []
            const txId = await sendAndConfirmTransaction(this.connection, tx, signers);
            console.log(`txhash: ${txId}`);
            return txId;
        } catch (err) {
            console.log(err)
        }
    }
}